!function() {
    function t(t, n, e) {
        var r = t.translate(),
            a = Math.atan2(n[1] - r[1], n[0] - r[0]) - Math.atan2(e[1] - r[1], e[0] - r[0]);
        return [Math.cos(a / 2), 0, 0, Math.sin(a / 2)]
    }
    function n(t, n) {
        var e = t.invert(n);
        return e && isFinite(e[0]) && isFinite(e[1]) && s(e)
    }
    function e(t) {
        var n = .5 * t[0] * l,
            e = .5 * t[1] * l,
            r = .5 * t[2] * l,
            a = Math.sin(n),
            o = Math.cos(n),
            i = Math.sin(e),
            s = Math.cos(e),
            c = Math.sin(r),
            u = Math.cos(r);
        return [o * s * u + a * i * c, a * s * u - o * i * c, o * i * u + a * s * c, o * s * c - a * i * u]
    }
    function r(t, n) {
        var e = t[0],
            r = t[1],
            a = t[2],
            o = t[3],
            i = n[0],
            s = n[1],
            c = n[2],
            u = n[3];
        return [e * i - r * s - a * c - o * u, e * s + r * i + a * u - o * c, e * c - r * u + a * i + o * s, e * u + r * c - a * s + o * i]
    }
    function a(t, n) {
        if (t && n) {
            var e = u(t, n),
                r = Math.sqrt(c(e, e)),
                a = .5 * Math.acos(Math.max(-1, Math.min(1, c(t, n)))),
                o = Math.sin(a) / r;
            return r && [Math.cos(a), e[2] * o, -e[1] * o, e[0] * o]
        }
    }
    function o(t, n) {
        var e = Math.max(-1, Math.min(1, c(t, n))),
            r = 0 > e ? -1 : 1,
            a = Math.acos(r * e),
            o = Math.sin(a);
        return o ? function(e) {
            var i = r * Math.sin((1 - e) * a) / o,
                s = Math.sin(e * a) / o;
            return [t[0] * i + n[0] * s, t[1] * i + n[1] * s, t[2] * i + n[2] * s, t[3] * i + n[3] * s]
        } : function() {
            return t
        }
    }
    function i(t) {
        return [Math.atan2(2 * (t[0] * t[1] + t[2] * t[3]), 1 - 2 * (t[1] * t[1] + t[2] * t[2])) * f, Math.asin(Math.max(-1, Math.min(1, 2 * (t[0] * t[2] - t[3] * t[1])))) * f, Math.atan2(2 * (t[0] * t[3] + t[1] * t[2]), 1 - 2 * (t[2] * t[2] + t[3] * t[3])) * f]
    }
    function s(t) {
        var n = t[0] * l,
            e = t[1] * l,
            r = Math.cos(e);
        return [r * Math.cos(n), r * Math.sin(n), Math.sin(e)]
    }
    function c(t, n) {
        for (var e = 0, r = t.length, a = 0; r > e; ++e)
            a += t[e] * n[e];
        return a
    }
    function u(t, n) {
        return [t[1] * n[2] - t[2] * n[1], t[2] * n[0] - t[0] * n[2], t[0] * n[1] - t[1] * n[0]]
    }
    function h(t) {
        for (var n = 0, e = arguments.length, r = []; ++n < e;)
            r.push(arguments[n]);
        var a = d3.dispatch.apply(null, r);
        return a.of = function(n, e) {
            return function(r) {
                try {
                    var o = r.sourceEvent = d3.event;
                    r.target = t, d3.event = r, a[r.type].apply(n, e)
                } finally {
                    d3.event = o
                }
            }
        }, a
    }
    var l = Math.PI / 180,
        f = 180 / Math.PI;
    d3.geo.zoom = function() {
        function c(t) {
            p++ || t({
                type: "zoomstart"
            })
        }
        function u(t) {
            t({
                type: "zoom"
            })
        }
        function l(t) {
            --p || t({
                type: "zoomend"
            })
        }
        var f,
            d,
            v,
            p = 0,
            g = h(m, "zoomstart", "zoom", "zoomend"),
            m = d3.behavior.zoom().on("zoomstart", function() {
                var o = d3.mouse(this),
                    s = e(f.rotate()),
                    h = n(f, o);
                h && (v = h), b.call(m, "zoom", function() {
                    f.scale(M.k = d3.event.scale);
                    var e = d3.mouse(this),
                        c = a(v, n(f, e));
                    f.rotate(M.r = i(s = c ? r(s, c) : r(t(f, o, e), s))), o = e, u(g.of(this, arguments))
                }), c(g.of(this, arguments))
            }).on("zoomend", function() {
                b.call(m, "zoom", null), l(g.of(this, arguments))
            }),
            b = m.on,
            M = {
                r: [0, 0, 0],
                k: 1
            };
        return m.rotateTo = function(t) {
            var n = a(s(t), s([-M.r[0], -M.r[1]]));
            return i(r(e(M.r), n))
        }, m.projection = function(t) {
            return arguments.length ? (f = t, M = {
                r: f.rotate(),
                k: f.scale()
            }, m.scale(M.k)) : f
        }, m.duration = function(t) {
            return arguments.length ? (d = t, m) : d
        }, m.event = function(t) {
            t.each(function() {
                var t = d3.select(this),
                    n = g.of(this, arguments),
                    r = M,
                    a = d3.transition(t);
                if (a !== t) {
                    a.each("start.zoom", function() {
                        this.__chart__ && (M = this.__chart__), f.rotate(M.r).scale(M.k), c(n)
                    }).tween("zoom:zoom", function() {
                        var t = m.size()[0],
                            s = o(e(M.r), e(r.r)),
                            c = d3.geo.distance(M.r, r.r),
                            h = d3.interpolateZoom([0, 0, t / M.k], [c, 0, t / r.k]);
                        return d && a.duration(d(.001 * h.duration)), function(e) {
                            var r = h(e);
                            this.__chart__ = M = {
                                r: i(s(r[0] / c)),
                                k: t / r[2]
                            }, f.rotate(M.r).scale(M.k), m.scale(M.k), u(n)
                        }
                    }).each("end.zoom", function() {
                        l(n)
                    });
                    try {
                        a.each("interrupt.zoom", function() {
                            l(n)
                        })
                    } catch (s) {}
                } else
                    this.__chart__ = M, c(n), u(n), l(n)
            })
        }, d3.rebind(m, g, "on")
    }
}(), function() {
    function t(t, n) {
        var e = d3.geo.interpolate(t, n)(.5),
            r = i(i(d(t), d(n)), d(e)),
            o = 1 / a(r);
        r[0] *= o, r[1] *= o, r[2] *= o;
        var s = _.origin(f(r))().coordinates[0];
        return [{
            type: "Polygon",
            coordinates: [s]
        }, {
            type: "Polygon",
            coordinates: [s.slice().reverse()]
        }]
    }
    function n(t, n) {
        var e = t.pop();
        n < t.length && ((t[n] = e).index = n)
    }
    function e(t) {
        var n = t.a.p,
            e = t.b.p,
            h = t.c.p,
            l = i(c(t.c.p, t.a.p), c(t.b.p, t.a.p)),
            f = 1 / r(l),
            d = Math.sqrt(f),
            v = s(.5 * d * a(c(n, e)) * a(c(e, h)) * a(c(h, n))),
            p = .5 * f * r(c(e, h)) * o(c(n, e), c(n, h)),
            g = .5 * f * r(c(n, h)) * o(c(e, n), c(e, h)),
            m = .5 * f * r(c(n, e)) * o(c(h, n), c(h, e)),
            b = [p * n[0] + g * e[0] + m * h[0], p * n[1] + g * e[1] + m * h[1], p * n[2] + g * e[2] + m * h[2]],
            M = r(b);
        return M > F ? (b[0] *= M = 1 / Math.sqrt(M), b[1] *= M, b[2] *= M) : b = t.n, u(t, b) || (b[0] *= -1, b[1] *= -1, b[2] *= -1, v = z - v, b.negative = !0), b.radius = v, b
    }
    function r(t) {
        return o(t, t)
    }
    function a(t) {
        return Math.sqrt(r(t))
    }
    function o(t, n) {
        return t[0] * n[0] + t[1] * n[1] + t[2] * n[2]
    }
    function i(t, n) {
        return [t[1] * n[2] - t[2] * n[1], t[2] * n[0] - t[0] * n[2], t[0] * n[1] - t[1] * n[0]]
    }
    function s(t) {
        return Math.asin(Math.max(-1, Math.min(1, t)))
    }
    function c(t, n) {
        return [t[0] - n[0], t[1] - n[1], t[2] - n[2]]
    }
    function u(t, n) {
        return o(t.n, n) - o(t.n, t.a.p) > F
    }
    function h(t, n) {
        return Math.abs(o(t.n, n) - o(t.n, t.a.p)) <= F
    }
    function l(t) {
        var n = 1 / a(t);
        return t[0] *= n, t[1] *= n, t[2] *= n, t
    }
    function f(t) {
        return [Math.atan2(t[1], t[0]) * w, s(t[2]) * w]
    }
    function d(t) {
        var n = t[0] * k,
            e = t[1] * k,
            r = Math.cos(e);
        return [r * Math.cos(n), r * Math.sin(n), Math.sin(e)]
    }
    function v(t, n, e) {
        var r;
        this.t = t, this.v = n, this.i = e, this.prevF = null, (r = this.nextF = n.visible) && (r.prevF = this), n.visible = this
    }
    function p(t, n, e) {
        u(t, n) && t.visible.push(new v(t, n, e))
    }
    function g(t, n, e) {
        for (var r = n.visible, a = e.visible, o = r.length, i = a.length, s = 0, c = 0; o > s || i > c;)
            if (o > s) {
                var u = r[s];
                if (i > c) {
                    var h = a[c];
                    if (u.i > h.i) {
                        p(t, h.v, h.i), ++c;
                        continue
                    }
                    u.i === h.i && ++c
                }
                p(t, u.v, u.i), ++s
            } else {
                var h = a[c];
                p(t, h.v, h.i), ++c
            }
    }
    function m(t, n, e, r) {
        this.visible = [], this.marked = !1, this.n = l(i(c(e, t), c(n, t))), (((this.a = new b(this, t)).next = this.b = new b(this, n)).next = this.c = new b(this, e)).next = this.a, this.index = r
    }
    function b(t, n) {
        this.triangle = t, this.p = n, this.neighbor = this.next = null
    }
    function M(t) {
        return !t.triangle.marked && t.neighbor.triangle.marked
    }
    function y(t) {
        if (!(t = t.neighbor).triangle.marked)
            for (var n = [t], e = t;;)
                if (M(t = t.next)) {
                    if (t === e)
                        return n;
                    n.push(t)
                } else
                    t = t.neighbor
    }
    function x(t, n) {
        (t.neighbor = n).neighbor = t
    }
    var z = Math.PI,
        w = 180 / z,
        k = z / 180,
        F = 1e-15,
        _ = d3.geo.circle().angle(90);
    d3.geo.voronoi = function(n, e) {
        arguments.length < 2 && (e = d3.geo.delaunay(n)), e || (e = []);
        var r = n.length,
            a = [];
        return e.forEach(function(t) {
            a[t.a.p.i] = t.a, a[t.b.p.i] = t.b
        }), {
            type: "GeometryCollection",
            geometries: 1 === r ? [{
                type: "Sphere"
            }] : 2 === r ? t(n[0], n[1]) : n.map(function(t, e) {
                var r = [],
                    s = [],
                    c = {
                        type: "Polygon",
                        coordinates: [r],
                        neighbors: s
                    },
                    u = a[e],
                    h = u,
                    v = h;
                if (!v)
                    return null;
                for (var p = v.triangle.centre;;) {
                    var g = v.triangle.centre;
                    if (o(g, p) < F - 1) {
                        var m = d(n[v.neighbor.p.i]),
                            b = d(n[v.p.i]),
                            M = l([m[0] + b[0], m[1] + b[1], m[2] + b[2]]);
                        o(g, i(m, b)) > 0 && (M[0] = -M[0], M[1] = -M[1], M[2] = -M[2]), r.push(f(M))
                    }
                    if (r.push(f(g)), s.push(v.neighbor.p.i), p = g, v === u && h !== u)
                        break;
                    v = (h = v).next.next.neighbor
                }
                return c
            })
        }
    }, d3.geo.voronoi.topology = function(t, n) {
        arguments.length < 2 && (n = d3.geo.delaunay(t)), n || (n = []);
        var e = t.length,
            r = new Array(e),
            a = [],
            o = -1,
            i = {},
            s = [];
        return n.forEach(function(t) {
            s[t.a.p.i] = t.a, s[t.b.p.i] = t.b
        }), t.forEach(function(t, n) {
            var e = [],
                c = [],
                u = s[n],
                h = u,
                l = h;
            if (!l)
                return null;
            for (;;) {
                if (l !== h) {
                    var d = h.triangle.index,
                        v = l.triangle.index,
                        p = v > d ? d + "," + v : v + "," + d,
                        g = i[p];
                    null == g && (a[g = i[p] = ++o] = v > d ? [f(h.triangle.centre), f(l.triangle.centre)] : [f(l.triangle.centre), f(h.triangle.centre)]), e.push(v > d ? g : ~g), c.push(l.neighbor.p.i)
                }
                if (l === u && h !== u)
                    break;
                l = (h = l).neighbor.next
            }
            r[n] = {
                type: "Polygon",
                neighbors: c,
                arcs: [e]
            }
        }), {
            objects: {
                voronoi: {
                    type: "GeometryCollection",
                    geometries: r
                }
            },
            arcs: a
        }
    }, d3.geo.delaunay = function(t) {
        var n = t.map(d),
            r = (t.length, d3.convexhull3d(n));
        return r.length ? (r.forEach(function(n) {
            n.coordinates = [t[n.a.p.i], t[n.b.p.i], t[n.c.p.i]], n.centre = e(n)
        }), r) : void 0
    }, d3.convexhull3d = function(t) {
        var e = t.length;
        if (4 > e)
            return [];
        for (var r = 0; e > r; ++r)
            t[r].i = r;
        d3.shuffle(t);
        for (var a = t[0], o = t[1], i = t[2], s = new m(a, o, i), r = 3; e > r && h(s, t[r]); ++r)
            ;
        if (r === e)
            return [];
        var c = t[r];
        if (t[r] = t[3], t[3] = c, u(s, c)) {
            var l = o;
            o = i, i = l
        }
        var f = new m(a, o, i, 0),
            d = new m(c, o, a, 1),
            v = new m(i, c, a, 2),
            b = new m(o, c, i, 3),
            M = [f, d, v, b];
        x(f.a, d.b), x(f.b, b.c), x(f.c, v.c), x(d.a, b.a), x(b.b, v.a), x(v.b, d.c);
        for (var r = 4; e > r; ++r) {
            var z = t[r];
            p(f, z, r), p(d, z, r), p(v, z, r), p(b, z, r)
        }
        for (var r = 4; e > r; ++r) {
            var z = t[r],
                w = z.visible;
            if (w) {
                var k = null,
                    a = w;
                do a.t.marked = !0;
                while (a = a.nextF);
                a = w;
                do {
                    var s = a.t;
                    if (k = y(s.a) || y(s.b) || y(s.c))
                        break
                } while (a = a.nextF);
                if (k) {
                    for (var F = 0, _ = k.length, j = null, P = null; _ > F; ++F) {
                        var E = k[F],
                            A = E.triangle,
                            q = E.neighbor.triangle,
                            s = new m(z, E.neighbor.p, E.p, M.length);
                        x(s.b, E), j ? x(j.a, s.c) : P = s, g(s, A, q), M.push(j = s)
                    }
                    x(j.a, P.c), a = w;
                    do {
                        for (var s = a.t, F = 0, _ = s.visible.length; _ > F; ++F)
                            s.visible[F].remove();
                        s.visible.length = 0, n(M, s.index)
                    } while (a = a.nextF)
                }
            }
        }
        return M
    }, v.prototype.remove = function() {
        this.prevF ? this.prevF.nextF = this.nextF : this.v.visible = this.nextF, this.nextF && (this.nextF.prevF = this.prevF)
    }
}(), function() {
    function t(t, n, e, r) {
        o.append("path").datum(topojson.feature(e, e.objects.ocean)).attr("class", "ocean").attr("d", a);
        var s = r.map(function(t) {
                return t.coordinates
            }),
            c = {
                type: "MultiPoint",
                coordinates: s
            };
        o.append("path").datum(c).attr("class", "points").attr("d", a);
        var u = d3.geo.delaunay(s),
            h = d3.geo.voronoi(r, u).geometries;
        h.forEach(function(t, n) {
            t.name = r[n].name + ", " + r[n].region
        }), o.append("path").datum(d3.geo.graticule()).attr("class", "graticule").attr("d", a), o.append("path").datum({
            type: "Sphere"
        }).attr("class", "outline").attr("d", a), o.selectAll(".voronoi").data(h).enter().insert("path", ".ocean").attr("class", "voronoi").style("fill", function(t) {
            return i(t.color = 0 | d3.max(t.neighbors, function(t) {
                return h[t].color
            }) + 1)
        }).attr("d", a).append("title").text(function(t) {
            return t.name
        }), o.insert("path", ".ocean").datum(topojson.mesh(n, n.objects.countries, function(t, n) {
            return t !== n
        })).attr("class", "countries").attr("d", a), o.selectAll(".voronoi-border").data(h.map(function(t) {
            return {
                type: "LineString",
                coordinates: t.coordinates[0]
            }
        })).enter().insert("path", ".ocean").attr("class", "voronoi-border").attr("d", a)
    }
    var n = 960,
        e = 500,
        r = d3.geo.orthographic().clipAngle(90).clipExtent([[1, 1], [n - 1, e - 1]]).precision(.1).translate([n / 2, e / 2]).scale(e / 2 - 1).rotate([-30, -30]),
        a = d3.geo.path().projection(r).pointRadius(1.5),
        o = d3.selectAll("#map").append("svg").attr("width", n).attr("height", e).call(d3.geo.zoom().projection(r).on("zoom.redraw", function() {
            o.selectAll("path").attr("d", a)
        })),
        i = d3.scale.category20b();
    queue().defer(d3.json, "../../world-110m.json").defer(d3.json, "ocean.json").defer(d3.json, "cities.json").await(t)
}();

